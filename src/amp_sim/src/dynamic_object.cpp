#include "amp_sim/dynamic_object.hpp"


DynamicObject::DynamicObject(double Mass, std::vector<int> lockedStates, std::string name, bool Gravity){
    object_name = name;
    mass = Mass;

    gravity = Gravity;

    state.setZero();

    //create a mask of which states are allowed to change dynamically
    //usefull for modelling a floor
    for(int i = 0; i < 12; i++){
        locked_states.push_back(true);
    }

    for(int i = 0; i < lockedStates.size(); i++){
        if(lockedStates.at(i) < 12){
            locked_states.at(lockedStates.at(i)) = false;
        }
    }
}

void DynamicObject::tic(V12d control, double current_time){

    //if there isn't a stashed pervious tick, stash one
    if(previous_tic < 0){
        previous_tic = current_time;
        return;
    }

    bool ending = false;

    while(!ending){

        //previous time
        double dt = current_time - previous_tic;

        if(dt > 0.01){
            dt = 0.01;
        } else {
            ending = true;
        }

        //convert to euler angles
        Eigen::Quaterniond current_or(state[3], state[4], state[5], state[6]);
        Eigen::Matrix3d current_rot = current_or.toRotationMatrix();
        V3d current_eul = current_rot.eulerAngles(2, 1, 0);

        //create the current state to be integrated
        V12d current_full_state;
        current_full_state[0] = state[0];
        current_full_state[1] = state[1];
        current_full_state[2] = state[2];
        current_full_state[3] = current_eul[2];
        current_full_state[4] = current_eul[1];
        current_full_state[5] = current_eul[0];
        current_full_state[6] = state[7];
        current_full_state[7] = state[8];
        current_full_state[8] = state[9];
        current_full_state[9] = state[10];
        current_full_state[10] = state[11];
        current_full_state[11] = state[12];

        V12d g_vector;
        g_vector.setZero();
        if(gravity){
            g_vector[8] = GRAVITATIONAL_CONSTANT;
        }


        //perform runge kutta integration
        V12d k1 = getAMatrix(current_full_state) * current_full_state + getBMatrix(current_full_state) * control;
        V12d k2 = getAMatrix(current_full_state + k1 * dt / 2) * (current_full_state  + k1 * dt / 2) + getBMatrix(current_full_state + k1 * dt / 2) * control;
        V12d k3 = getAMatrix(current_full_state + k2 * dt / 2) * (current_full_state  + k2 * dt / 2) + getBMatrix(current_full_state + k2 * dt / 2) * control;
        V12d k4 = getAMatrix(current_full_state + k3 * dt) * (current_full_state  + k3 * dt) + getBMatrix(current_full_state + k3 * dt) * control;

        V12d d_state = ((k1 + 2 * k2 + 2 * k3 + k4) / 6 + g_vector )* dt ;

        //don't increment the locked states

        //step the state and time
        state[0] +=  d_state[0] * locked_states.at(0);
        state[1] +=  d_state[1] * locked_states.at(1);
        state[2] +=  d_state[2] * locked_states.at(2);
        state[7] +=  d_state[6] * locked_states.at(6);
        state[8] +=  d_state[7] * locked_states.at(7);
        state[9] +=  d_state[8] * locked_states.at(8);
        state[10] +=  d_state[9] * locked_states.at(9);
        state[11] +=  d_state[10] * locked_states.at(10);
        state[12] +=  d_state[11] * locked_states.at(11);

        //convert back to quaternion
        //Next for lines where partially generated by Google Gemni 
        //"eigen quaternion from euler"
        Eigen::Quaterniond updated_or;
        updated_or = Eigen::AngleAxisd(current_full_state[5] + d_state[5] * locked_states.at(5), Eigen::Vector3d::UnitZ()) *
            Eigen::AngleAxisd(current_full_state[4] + d_state[4] * locked_states.at(4), Eigen::Vector3d::UnitY()) *
            Eigen::AngleAxisd(current_full_state[3] + d_state[3] * locked_states.at(3), Eigen::Vector3d::UnitX());

        state[3] = updated_or.w();
        state[4] = updated_or.x();
        state[5] = updated_or.y();
        state[6] = updated_or.z();

        previous_tic = previous_tic + dt;
    }

}

M12d DynamicObject::getAMatrix(V12d current_state){

    //can be override for systems with complex dynamics
    M12d a_mat;
    a_mat.setZero();

    a_mat(0,6) = 1;
    a_mat(1,7) = 1;
    a_mat(2,8) = 1;
    a_mat(3,9) = 1;
    a_mat(4,10) = 1;
    a_mat(5,11) = 1;

    return a_mat;
}

M12d DynamicObject::getBMatrix(V12d current_state){

    //can be override for systems with complex dynamics
    M12d b_mat;
    b_mat.setZero();

    return b_mat;
}

bool DynamicObject::check_state_bounds(){
    //returns false if the object is out of the state bounds

    if(state[0] > STATE_X_BOUNDS || state[0] < -STATE_X_BOUNDS){
        return false;
    }

    if(state[1] > STATE_Y_BOUNDS || state[1] < -STATE_Y_BOUNDS){
        return false;
    }

    if(state[2] > STATE_Z_BOUNDS || state[2] < -STATE_Z_BOUNDS){
        return false;
    }

    return true;
}

V12d DynamicObject::invert_control(V12d control){   
    //this shouldn't be called...

    return V12d();
};

